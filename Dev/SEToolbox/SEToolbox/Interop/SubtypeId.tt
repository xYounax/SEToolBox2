<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="$(TargetDir)SEToolbox.exe" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="SEToolbox.Support" #>
<#@ output extension=".cs" #>
namespace SEToolbox.Interop
{
    /// <summary>
    /// Generated by Text Templating on Game Engine data file 'CubeBlocks.sbc'.
    /// </summary>
    public enum SubtypeId
    {
        Empty = 0,

        // Although not enumerated in the Space Engineers API, I'm autogenerating enumerations
        // direct from the game source here to make sure we have strongly typed names when generating content,
        // rather than relying upon hardcoded 'strings' which required maintenance.
        // When checking content read from 'world' saves however, we will have to rely upon the game data.

<#
        // NOTE: The template will not run unless the solution has been built in AnyCPU configuration

        string appPath = ToolboxUpdater.GetApplicationFilePath();

        if (appPath != null)
            appPath = Path.Combine(appPath, "..");
        else
            appPath = ToolboxUpdater.GetGameRegistryFilePath();

        if (appPath == null)
        {
            Write("#warning Could not generate enums, because Space Engineers is not installed on the Developer machine. \r\n\r\n");
        }
        else
        {
            try
            {
                var cubeBlocksFolder = Path.Combine(appPath, @"Content\Data\CubeBlocks");
                var list = new List<string>();

                foreach (var filename in Directory.GetFiles(cubeBlocksFolder))
                {
                    var xDoc = new XmlDocument();
                    xDoc.Load(filename);

                    var nav = xDoc.CreateNavigator();
                    var definitions = nav.Select("Definitions/CubeBlocks/Definition");

                    while (definitions.MoveNext())
                    {
                        var fullName = definitions.Current.SelectSingleNode("Id/SubtypeId").Value;
                        var name = fullName.Replace(" ", "_");
                        var originalName = fullName != name ? fullName : "";

                        if (list.Contains(name))
                            continue;

                        if (definitions.Current.SelectSingleNode("Variants") != null)
                        {
                            Write(string.Format("        {0},\r\n", name));

                            var variants = definitions.Current.Select("Variants/Variant");

                            while (variants.MoveNext())
                            {
                                var variant = variants.Current.SelectSingleNode("@Color").Value;
                                Write(string.Format("        {0}{1},\r\n", name, variant));
                            }
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(originalName))
                            {
                                Write(string.Format("        {0},        // '{1}'\r\n", name, originalName));
                            }
                            else if (!string.IsNullOrEmpty(name))
                            {
                                Write(string.Format("        {0},\r\n", name));
                            }

                            list.Add(name);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Write(string.Format("#warning An exception occured during transformation. {0}\r\n\r\n", ex.Message.Replace("\r\n", "")));
            }
        }
#>
    };
}